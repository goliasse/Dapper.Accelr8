<#@ template debug="true" hostspecific="true" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="EnvDTE" #>
<#@ assembly name="System.Data" #>
<#@ assembly name="System.Data.DataSetExtensions" #>
<#@ import namespace="EnvDTE" #>
<#@ import namespace="System.Diagnostics" #>
<#@ import namespace="System.Collections" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Text.RegularExpressions" #>
<#@ import namespace="System.Globalization" #>
<#@ import namespace="System.Data" #>
<#@ import namespace="System.Data.SqlClient" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="Microsoft.VisualStudio.TextTemplating" #>
<#@ import namespace="System.Runtime.InteropServices" #>
<#@ output extension=".cs" #>
<#@ include file="Includes\\Accelr8or.ttinclude" #>
<#@ include file="Includes\\DbHelper.ttinclude" #>
<#@ include file="Includes\\Manager.ttinclude" #>
<#@ include file="Schema.ttinclude" #>

<#
	var className = @"";
	var idType = @"";
	var entityType = @"";
	var idField = @"";

	var tables = SchemaHelper.GetTables();

	var manager = Manager.Create(Host, GenerationEnvironment);

	// Generate EntityWriters
	foreach (var t in tables.Where(tb => !tb.Value.Ignore && !tb.Value.ReadOnly))
	{
		var table = t.Value;

		Debug.WriteLine("Starting EntityWriter for Table {0} ", t.Key);

		var name = Accelr8or.Inflector.MakeSingular(table.ClassName ?? table.TableName);

		className = name + "Writer";
		if (table.Columns.Any(c => c.IsPrimaryKey))
		{
			idType = table.Columns.First(c => c.IsPrimaryKey).CSharpType;
			idField = table.Columns.First(c => c.IsPrimaryKey).ColumnName;
		}
		else
		{
			idType = table.Columns.First().CSharpType;
			idField = table.Columns.First().ColumnName;
		}

		entityType = name;

		manager.StartNewFile(Path.Combine(SchemaHelper.WritersDirectory, name + "Writer.cs")); #>

using System;
using System.Collections.Generic;
using System.Data;
using System.Dynamic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using <#= SchemaHelper.DomainNamespace #>;
using <#= SchemaHelper.TableInfoNamespace #>;
using Dapper;
using Dapper.Accelr8.Sql;
using Dapper.Accelr8.Repo;
using Dapper.Accelr8.Repo.Parameters;
using Dapper.Accelr8.Repo.Contracts.Writers;

namespace <#= SchemaHelper.WritersNamespace #>
{
    public class <#= className #> : EntityWriter<<#= idType #>, <#= entityType #>>
    {
        public <#= className #>
			(TableInfo tableInfo
            , string connectionStringName
            , DapperExecuter executer
            , QueryBuilder queryBuilder
            , JoinBuilder joinBuilder
			, IServiceLocatorMarker locator) 
            : base(tableInfo, connectionStringName, executer, queryBuilder, joinBuilder, locator)
		{

		}

		<# foreach (var child in table.Children.Where(c => !c.Ignore && !c.OneToOne).GroupBy(c => c.ChildClassName).Select(s => s.First()))
			{ 
				var cidType = child.CSharpType;
				var ceType = child.ChildClassName;
#>
static IEntityWriter<<#= cidType #> , <#= ceType #>> Get<#= ceType #>Writer()
		{ return _locator.Resolve<IEntityWriter<<#= cidType #> , <#= ceType #>>>(); }
		<# } #>

		/// <summary>
		/// 
		/// </summary>
		/// <param name="results">Parameters for sql writes</param>
		/// <param name="row"></param>
        protected override IDictionary<string, object> GetParams(ActionType actionType, <#= entityType #> entity, int taskIndex, int count)
        {
            var parms = new Dictionary<string, object>();

		<# foreach (var col in table.Columns.Where(c => !c.Ignore))
		{#>
	parms.Add(GetParamName(<#= entityType #>ColumnNames.<#= col.ColumnName #>.ToString(), actionType, taskIndex, count), <# if (col.CastType != null) { #> (<#= col.CastType #>) <# } #>entity.<#= col.FieldName #>);
		<#}#>
			
			return parms;
        }


		protected override void CascadeRelations(<#= entityType #> entity, ScriptContext context)
        {
            if (entity == null)
                return;

		<# foreach (var child in table.Children.Where(c => !c.Ignore && !c.OneToOne))
		{ 
			var writerName = Accelr8or.Inflector.MakeInitialLowerCase(child.ChildClassName);
			#>
	//From Foreign Key <#= child.Name #>
			var <#= writerName #> = Get<#= child.ChildClassName #>Writer();
			if (_cascades.Contains(<#= entityType #>CascadeNames.<#= Accelr8or.Inflector.MakeSingular(child.Table).ToLower() #>.ToString()))
				foreach (var item in entity.<#= Accelr8or.Inflector.MakePlural(child.ChildClassName) #>)
					Cascade(<#= writerName #>, item, context);

			if (<#= writerName #>.Count > 0)
				WithChild(<#= writerName #>, entity);

		<# } #>

        }


	}
}
		<# manager.EndBlock();
	}

	manager.Process(true);
#>